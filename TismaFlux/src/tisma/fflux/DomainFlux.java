/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tisma.fflux;

import helpers.TLogger;
import helpers.TParser;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.jms.JMSException;
import org.jnetpcap.packet.format.FormatUtils;


/**
 *
 * @author Lukas Lences
 */
public class DomainFlux implements Runnable{
    private final static Logger LOGGER = Logger.getLogger(TLogger.class.getName());
    public static Map<String, ArrayList<DnsResponse>> errHosts;
    static ArrayList<DnsResponse> dnsErrorsResponse;
    ArrayList<String> infectedIp;
    ArrayList<String> infectedDomains;
    static int MAXIMUM_TIME_NXDOMAIN;
    final private String url;
    final private String queue;
    final private String filename;
    Thread t;
    
    DomainFlux(int MAXIMUM_TIME, ArrayList<DnsResponse> errorResponses, String u, String q, String f) {
        url = u;
        queue = q;
        filename = f;
        MAXIMUM_TIME_NXDOMAIN = MAXIMUM_TIME;
        dnsErrorsResponse = errorResponses;
        t = new Thread(this);
        t.start();
    }
    
    public void run(){
        LOGGER.log(Level.FINE, "Starting domain flux checking...");
        detectDomainFlux();
        getInfectedByDomainFlux();        
        try {
            sendMessage();
        } catch (JMSException ex) {
            Logger.getLogger(DomainFlux.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    static void detectDomainFlux() {
        errHosts = new HashMap();
        for (DnsResponse dr : dnsErrorsResponse) {
            if (errHosts.containsKey(FormatUtils.ip(dr.dIP))) {
                //String domainname = dr.responses.get(0).name;
                ArrayList<DnsResponse> pa = errHosts.get(FormatUtils.ip(dr.dIP));

                //vsetky starsie ako tento - time interval zmazat
                Date lastDate = new Date(dr.responses.get(0).timestamp.getTime() - MAXIMUM_TIME_NXDOMAIN);
                ArrayList<DnsResponse> toDelete = new ArrayList<>();
                for (DnsResponse resp : pa) {
                    if (resp.responses.get(0).timestamp.before(lastDate)) {
                        toDelete.add(resp);
                    }                 
                }
                for (DnsResponse resp : toDelete) {
                    pa.remove(resp);
                }
                pa.add(dr);
            } else {
                ArrayList<DnsResponse> pa = new ArrayList<>();
                pa.add(dr);
                errHosts.put(FormatUtils.ip(dr.dIP), pa);
            }
        }
    }
    
    void getInfectedByDomainFlux(){
        infectedIp = new ArrayList<>();
        infectedDomains = new ArrayList<>();
        
        for (Map.Entry<String, ArrayList<DnsResponse>> entry : errHosts.entrySet()){
            infectedIp.add(entry.getKey());
            ArrayList<DnsResponse> domains = entry.getValue();
            for (DnsResponse resp : domains){
                for (Response r : resp.responses)
                    infectedDomains.add(r.name);
            }
        }
    }
    
    void sendMessage() throws JMSException{
        if (infectedIp.size() > 0){
           LOGGER.log(Level.FINE, "Sending domain flux to MQ...");
           FluxToQueue.sendToFastFlux(url, TParser.generateJson(filename, 
                   "DOMAIN-FLUX", infectedDomains, infectedIp), queue);
       }
    }
}
