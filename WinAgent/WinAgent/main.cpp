//#include <winsock.h>
//#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>
#include <thread>
#include <mutex>
#include <time.h>
#include <direct.h>
#include <errno.h>
#include <windivert.h>

#include <Windows.h>

// test
#include "Configuration.hpp"
#include "Windivert.hpp"


#define MAXBUF  0xFFFF
#define LINE 200
#define TMP_DIRNAME "Tmp\\"
#define DATA_DIRNAME "Final\\"
#define STOP_TIME 180 //cas, po ktorom skonci vlakno, pokial neprichadzaju pakety
#define SEND_TIME 5//200 //cas, po uplynuti ktoreho sa zacinaju posielat data na Collector
#define MAXFILESIZE 60000000
#define MAXPATH 150

using namespace std;

typedef struct {
	string ipAddr;
	string port;
} collectors;

typedef struct {
	string agentName;
	string ipProt;
	string srcAddr;
	string dstAddr;
	string coreProt;
	string srcPort;
	string dstPort;
	string bound;
	vector<collectors> collectors;
} configuration;

map<size_t, vector<vector<unsigned char>>> packets;
map<size_t, vector<UINT>> packets_len;
map<UINT16, time_t> packets_time;
std::mutex mu;
std::mutex mu2;
std::mutex mu3;
char path[MAXPATH];


configuration agentConfig;


int setConfig() {

	ifstream configFile;
	char line[LINE];
	string file(path);
	file.append("config_agent.xml");
	configFile.open(file.c_str());
	string tags[] = { "Collector", "Name", "IP_Protocol", "SrcAddr", "DstAddr", "CoreProtocol", "SrcPort", "DstPort", "Bound" };
	collectors tmpColl;
	size_t pos;
	bool agent, sender;

	if (!configFile.is_open()) {

		cerr << "Konfiguracny subor sa nepodarilo nacitat." << endl;
		return -1;
	}

	while (!configFile.eof()) {

		configFile.getline(&line[0], LINE - 1);

		string strLine(line);

		if (strLine.find("Sender") != -1) {
			sender = true;
		}


		if (strLine.find("Agent") != -1) {
			agent = true;
		}


		if (strLine.find("/Sender") != -1) {
			sender = false;
		}

		if (strLine.find("/Agent") != -1) {
			agent = false;
		}

		if (sender == true) {
			if (strLine.find(tags[0]) != -1) {
				strLine.erase(0, tags[0].length() + 3);
				strLine.erase(strLine.find("<"), tags[0].length() + 4);
				if ((pos = strLine.find(":")) != -1) {
					tmpColl.port.append(strLine.substr(pos + 1, strLine.length() - pos));
					strLine.erase(pos, strLine.length() - pos);
					tmpColl.ipAddr.append(strLine);
					agentConfig.collectors.push_back(tmpColl);
				}
				tmpColl.ipAddr.clear();
				tmpColl.port.clear();
			}
		}

		if (agent == true) {

			if (strLine.find(tags[1]) != -1) {
				strLine.erase(0, tags[1].length() + 2);
				strLine.erase(strLine.find("<"), tags[1].length() + 3);
				agentConfig.agentName = strLine;
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[2]) != -1) {
					strLine.erase(0, tags[2].length() + 2);
					strLine.erase(strLine.find("<"), tags[2].length() + 3);
					agentConfig.ipProt = strLine;
				}
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[3]) != -1) {
					strLine.erase(0, tags[3].length() + 2);
					strLine.erase(strLine.find("<"), tags[3].length() + 3);
					agentConfig.srcAddr = strLine;
				}
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[4]) != -1) {
					strLine.erase(0, tags[4].length() + 2);
					strLine.erase(strLine.find("<"), tags[4].length() + 3);
					agentConfig.dstAddr = strLine;
				}
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[5]) != -1) {
					strLine.erase(0, tags[5].length() + 2);
					strLine.erase(strLine.find("<"), tags[5].length() + 3);
					agentConfig.coreProt = strLine;
				}
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[6]) != -1) {
					strLine.erase(0, tags[6].length() + 2);
					strLine.erase(strLine.find("<"), tags[6].length() + 3);
					agentConfig.srcPort = strLine;
				}
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[7]) != -1) {
					strLine.erase(0, tags[7].length() + 2);
					strLine.erase(strLine.find("<"), tags[7].length() + 3);
					agentConfig.dstPort = strLine;
				}
			}

			if (strLine.find("#") == -1) {
				if (strLine.find(tags[8]) != -1) {
					strLine.erase(0, tags[8].length() + 2);
					strLine.erase(strLine.find("<"), tags[8].length() + 3);
					agentConfig.bound = strLine;
				}
			}

		}
	}

	if (agentConfig.agentName.empty()) {
		cerr << "Nie je nastaveny povinny parameter Name." << endl;
		return -1;
	}
	else if (agentConfig.collectors.empty()) {
		cerr << "Nie je nastaveny povinny parametere pre Collector." << endl;
		return -1;
	}

	return 0;
}

string makeSettings() {
	string setting;
	if (!agentConfig.bound.empty()) {
		setting.append(agentConfig.bound);
	}

	if (!agentConfig.ipProt.empty()) {

		if (agentConfig.ipProt.find("IPv4") != -1) {
			setting.append(" and ip");
		}

		if (agentConfig.ipProt.find("IPv6") != -1) {
			setting.append(" and ipv6");
		}
	}

	if (!agentConfig.srcAddr.empty()) {

		setting.append(" and ip.SrcAddr == ");
		setting.append(agentConfig.srcAddr);
	}

	if (!agentConfig.dstAddr.empty()) {
		cout << agentConfig.dstAddr << endl;
		setting.append(" and ip.DstAddr == ");
		setting.append(agentConfig.dstAddr);
	}

	if (!agentConfig.coreProt.empty()) {

		if (agentConfig.coreProt.find("TCP") != -1) {

			if (!agentConfig.srcPort.empty()) {

				setting.append(" and tcp.SrcPort == ");
				setting.append(agentConfig.srcPort);
			}

			if (!agentConfig.dstPort.empty()) {

				setting.append(" and tcp.DstPort == ");
				setting.append(agentConfig.dstPort);
			}
		}

		if (agentConfig.coreProt.find("UDP") != -1) {

			if (!agentConfig.srcPort.empty()) {

				setting.append(" and udp.SrcPort == ");
				setting.append(agentConfig.srcPort);
			}

			if (!agentConfig.dstPort.empty()) {

				setting.append(" and udp.DstPort == ");
				setting.append(agentConfig.dstPort);
			}
		}

		if (agentConfig.coreProt.find("ICMP") != -1) {

			setting.append(" and icmp");
		}
	}

	return setting;
}

//funkcia, ktora konvertuje hash na string
string hashToString(size_t hash) {
	stringstream ss;

	ss << hash;

	return ss.str();
}

//funkcia vrati naformatovany aktualny cas a datum
string getTimeAndDate() {
	time_t raw_time;
	struct tm *time_info;
	int day, month, year, hour, minute, seconds;
	string dateTime;

	time(&raw_time);
	time_info = localtime(&raw_time);
	year = time_info->tm_year + 1900;
	month = time_info->tm_mon + 1;
	day = time_info->tm_mday;
	hour = time_info->tm_hour;
	minute = time_info->tm_min;
	seconds = time_info->tm_sec;

	dateTime.append(to_string(year));

	if (month < 10) {
		dateTime.append("0");
		dateTime.append(to_string(month));
	}
	else {
		dateTime.append(to_string(month));
	}

	if (day < 10) {
		dateTime.append("0");
		dateTime.append(to_string(day));
	}
	else {
		dateTime.append(to_string(day));
	}

	dateTime.append("_");

	if (hour < 10) {
		dateTime.append("0");
		dateTime.append(to_string(hour));
	}
	else {
		dateTime.append(to_string(hour));
	}

	if (minute < 10) {
		dateTime.append("0");
		dateTime.append(to_string(minute));
	}
	else {
		dateTime.append(to_string(minute));
	}

	if (seconds < 10) {
		dateTime.append("0");
		dateTime.append(to_string(seconds));
	}
	else {
		dateTime.append(to_string(seconds));
	}

	return dateTime;
}



//funkcia na zasielanie ziskanych dat na collector
int sendDataToCollector() {
	DWORD exitCode;
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInfo;
	int ret = 0;
	int count = 0;

	memset(&startupInfo, 0, sizeof(startupInfo));
	memset(&processInfo, 0, sizeof(processInfo));

	while (ret == 0) {

		if (count == agentConfig.collectors.size()) {
			cerr << "Nebolo mozne sa odoslat data na ziadny z Collectorov." << endl;
			break;
		}

		string pathDir(path);
		string arguments(path);
		pathDir.append("CollectorSender.exe");
		arguments.append("CollectorSender.exe ");
		arguments.append(path);
		arguments.append(DATA_DIRNAME);
		arguments.append(" " + agentConfig.collectors[count].ipAddr);
		arguments.append(" " + agentConfig.collectors[count].port);
		printf("%s\n", pathDir.c_str());
		//vytvorenie detskeho procesu - spustenie modulu na zasielanie
		if (!CreateProcess(pathDir.c_str(), (LPSTR)arguments.c_str(), NULL, FALSE, 0, NULL, NULL, NULL, &startupInfo, &processInfo)) {
			cerr << "Nepodarilo sa spustit modul na odosielanie dat na Collector. " << GetLastError() << endl;
		}

		//cakanie na skoncenie modulu pre zasielanie dat
		WaitForSingleObject(processInfo.hProcess, INFINITE);

		//zistenie navratovej hodnoty modulu pre zasielanie dat
		GetExitCodeProcess(processInfo.hProcess, &exitCode);
		ret = (int)exitCode;
		count++;
	}

	//zatvorenie handle-ov
	CloseHandle(processInfo.hProcess);
	CloseHandle(processInfo.hThread);

	return 0;
}

//funkcia, ktora sluzi na spracovanie zachytenych paketov
void processPackets(std::size_t hash) {
	//, u_char* Buffer, int Size //Zmena Stvrtok 4teho Maja pre WinpCap, u_char* Buffer, int Size
								  //===============Zmena stvrtok 4teho Maja=======================

								  /*
								  //Ethernet header
								  ethhdr = (ETH_HDR *)Buffer;
								  ++total;
								  //IP packets:
								  if(ntohs(ethhdr->type) == 0x0800)
								  {
								  //ip header
								  iphdr = (IPV4_HDR *)(Buffer + sizeof(ETHER_HDR));
								  switch (iphdr->ip_protocol)//for checking the protocol.
								  {
								  case 1:
								  icmp++;
								  PrintIcmpPacket(Buffer, Size);
								  break;
								  case 6:
								  tcp++;
								  PrintTcpPacket(Buffer, Size);
								  break;
								  default:
								  break;
								  }
								  }printf("TCP: %d ICMP: %d Total:", tcp, icmp, total);*/
								  //===============Koniec zmeny stvrtok 4teho Maja================
	clock_t begin;
	clock_t end;
	float timer = 0;
	thread::id id = this_thread::get_id(); //id vlakna
	map<size_t, vector<vector<unsigned char>>>::iterator it_p;
	map<size_t, vector<UINT>>::iterator it_pLen;
	vector<vector<unsigned char>> tmp_p; //pomocna premenna pre pakety
	vector<UINT> tmp_pLen; //pomocna premenna, v ktorej sa nachadzaju dlzky paketov
	FILE *filePackets, *filePacketsXML;
	string fileNameXML, identificator;
	unsigned char *packet;
	UINT packet_len;
	WINDIVERT_ADDRESS addr;
	PWINDIVERT_IPHDR ip_header;
	PWINDIVERT_IPV6HDR ipv6_header;
	PWINDIVERT_ICMPHDR icmp_header;
	PWINDIVERT_ICMPV6HDR icmpv6_header;
	PWINDIVERT_TCPHDR tcp_header;
	PWINDIVERT_UDPHDR udp_header;
	time_t syst;
	int count = 0; //pocitadlo paketov
	int countFiles = 1; //pocitadlo poctu vytvorenych suborov
	int fin = 0; //premenna na overenie prijatia FIN paketu
	int xml = 0; //premenna pre testovanie vytvorenia XML suboru
	int sizeWritten = 0; //premenna na testovanie velkosti vytvoreneho suboru




	identificator.append(agentConfig.agentName + "-");
	identificator.append(hashToString(hash));
	identificator.append("-");
	identificator.append(getTimeAndDate());

	string fileName(path);
	fileName.append(TMP_DIRNAME);
	fileName.append(identificator);

	//cout << "filename: " << fileName <<  endl;
	fileNameXML = fileName;
	fileName.append(".txt");
	filePackets = fopen(fileName.c_str(), "a");
	fileNameXML.append(".xml");
	filePacketsXML = fopen(fileNameXML.c_str(), "w");

	fprintf(filePackets, "\n%s\n\n", identificator.c_str());
	fprintf(filePacketsXML, "\n%s\n\n", identificator.c_str());


	begin = clock();
	//cyklus, ktory sa opakuje, ak nie je obdrzany finalny paket, resp. nepresiel urceny cas
	while (fin == 0) {
		//KO v ktorej sa nahraju do lokalneho adresneho priestoru vlakna zachytene pakety
		mu.lock();
		it_p = packets.find(hash);
		it_pLen = packets_len.find(hash);
		tmp_p = it_p->second;
		tmp_pLen = it_pLen->second;
		it_p->second.erase(it_p->second.begin(), it_p->second.end());
		it_pLen->second.erase(it_pLen->second.begin(), it_pLen->second.end());
		mu.unlock(); //koniec KO

					 //KO2 v ktorej sa vykonava zapisanie zachytenych paketov do suboru
		mu2.lock();
		if (tmp_p.size() == 0) {
			end = clock();
			timer = (float)(end - begin) / CLOCKS_PER_SEC;
			//printf("timer: %lf\n", timer);

			if (timer >= STOP_TIME) {
				fin = 1;

			}
		}
		for (int i = 0; i < tmp_p.size(); i++) {
			packet = &tmp_p[i][0];
			WinDivertHelperParsePacket(packet, tmp_pLen[i], &ip_header,
				&ipv6_header, &icmp_header, &icmpv6_header, &tcp_header,
				&udp_header, NULL, NULL);

			if (ip_header != NULL) {
				UINT8 *srcAddr = (UINT8*)&ip_header->SrcAddr;
				UINT8 *dstAddr = (UINT8*)&ip_header->DstAddr;

				if (tcp_header != NULL && (tcp_header->Fin == 1 && tcp_header->Ack == 1)) {
					fin = 1;
				}

				if (xml == 0) {
					xml = 1;
					fprintf(filePacketsXML, "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n");
					fprintf(filePacketsXML, "<item>\n");

					if (ip_header != NULL) {
						fprintf(filePacketsXML, "<SessID>%s</SessID>\n", identificator.c_str());
						fprintf(filePacketsXML, "<IP_Protocol>IPv4</IP_Protocol>\n");

						fprintf(filePacketsXML, "<SrcAddr>%u.%u.%u.%u</SrcAddr>\n", srcAddr[0], srcAddr[1], srcAddr[2], srcAddr[3]);
						fprintf(filePacketsXML, "<DstAddr>%u.%u.%u.%u</DstAddr>\n", dstAddr[0], dstAddr[1], dstAddr[2], dstAddr[3]);
					}

					if (tcp_header != NULL) {
						fprintf(filePacketsXML, "<CoreProtocol>TCP</CoreProtocol>\n");

						fprintf(filePacketsXML, "<SrcPort>%u</SrcPort>\n", ntohs(tcp_header->SrcPort));
						fprintf(filePacketsXML, "<DstPort>%u</DstPort>\n", ntohs(tcp_header->DstPort));
					}

					if (udp_header != NULL) {
						fprintf(filePacketsXML, "<CoreProtocol>UDP</CoreProtocol>\n");

						fprintf(filePacketsXML, "<SrcPort>%u</SrcPort>\n", ntohs(udp_header->SrcPort));
						fprintf(filePacketsXML, "<DstPort>%u</DstPort>\n", ntohs(udp_header->DstPort));
					}

				}
				//packets_time.find(packet)->second;

				//	SYSTEMTIME syst =  packets_time.find(packet)->second;
				//	sizeWritten +=  fprintf(filePackets,  "Datum: %02d.%02d.%02d         Cas: %02d:%02d:%02d:%02d  \n", syst.wDay,syst.wMonth,syst.wYear,syst.wHour,syst.wMinute,syst.wSecond,syst.wMilliseconds);
				syst = packets_time.at(ip_header->Id);
				sizeWritten += fprintf(filePackets, "%i\n", syst);

				for (int j = 0; j < tmp_pLen[i]; j++) {
					if (((j % 16) == 0) && (j != 0)) {
						sizeWritten += fprintf(filePackets, "\n");
						//printf("\n");
					}
					//printf("%.2X ", tmp_p[i][j]);
					sizeWritten += fprintf(filePackets, "%.2X ", packet[j]);

				}

				sizeWritten += fprintf(filePackets, "\n");
				sizeWritten += fprintf(filePackets, "End of packet\n\n");

				if (sizeWritten >= MAXFILESIZE) {
					fclose(filePackets);
					countFiles++;

					identificator.append("_");
					identificator.append(to_string(countFiles));

					fileName.clear();
					fileName.append(path);
					fileName.append(TMP_DIRNAME);
					fileName.append(identificator);
					fileNameXML = fileName;
					fileName.append(".txt");
					filePackets = fopen(fileName.c_str(), "a");

					fprintf(filePackets, "\n%s\n\n", identificator.c_str());
				}
				count++;
				//cout << endl << endl;
			}
		}
		tmp_p.empty();
		tmp_pLen.empty();
		mu2.unlock(); //koniec KO2


	}
	mu3.lock();
	fprintf(filePacketsXML, "<NoPackets>%i</NoPackets>\n", count);
	fprintf(filePacketsXML, "</item>\n");
	fprintf(filePacketsXML, "End of XML File\n");
	fprintf(filePackets, "End of Packets File\n");
	mu3.unlock();

	fclose(filePacketsXML);
	fclose(filePackets);
	string tmp(path);
	tmp.append(DATA_DIRNAME);
	tmp.append(identificator);
	tmp.append(".txt");
	if (rename(fileName.c_str(), tmp.c_str()) != 0) {
		cerr << "Nebolo mozne presunut subor " << fileName << " do priecinku " << DATA_DIRNAME << " " << GetLastError() << endl;
	}


	tmp.erase();
	tmp.append(path);
	tmp.append(DATA_DIRNAME);
	tmp.append(identificator);
	tmp.append(".xml");
	if (rename(fileNameXML.c_str(), tmp.c_str()) != 0) {
		cerr << "Nebolo mozne presunut subor " << fileNameXML << " do priecinku " << DATA_DIRNAME << " " << GetLastError() << endl;
	}

	tmp.erase();

	cout << "Session " << hash << " spracovana" << endl;
}

int createDirs() {
	int path_len;
	string tmp;

	if (_getcwd(path, sizeof(path)) == NULL) {
		cerr << "Nie je mozne ziskat cestu k pracovnemu priecinku. " << GetLastError() << endl;
		if (errno == ERANGE) {
			cerr << "Dlzka cesty priesiahla maximalnu dlzku " << MAXPATH << "." << endl;
		}
		return -1;
	}

	path_len = strlen(path);
	path[path_len] = '\\';
	path[path_len + 1] = '\0';

	tmp.append(path);
	tmp.append(TMP_DIRNAME);
	if (_mkdir(tmp.c_str()) == -1) {
		if (errno != EEXIST) {
			cerr << "Nie je mozne vytvorit priecinok pre temporarne subory. " << GetLastError() << endl;

			return -1;
		}
	}

	tmp.erase();
	tmp.append(path);
	tmp.append(DATA_DIRNAME);
	if (_mkdir(tmp.c_str()) == -1) {
		if (errno != EEXIST) {
			cerr << "Nie je mozne vytvorit priecinok pre subory urcene na odoslanie. " << GetLastError() << endl;

			return -1;
		}
	}
	printf("\n");
	return 0;
}

string getLocalIp() {


	char *searchIP = "   IPv4 Address. . . . . . . . . . . :";
	string line, ip;
	int offset;
	ifstream file1;
	system("ipconfig > subor.txt");
	file1.open("subor.txt");

	if (file1.is_open())
	{
		while (!file1.eof()) {
			getline(file1, line);

			if ((offset = line.find(searchIP)) != string::npos) {
				line.erase(0, 39);
				ip = line;
				file1.close();

			}
		}

	}
	remove("subor.txt");
	return ip;
}

time_t changeTimeFormat(SYSTEMTIME st) {
	tm  timeformat;


	timeformat.tm_sec = st.wSecond;
	timeformat.tm_min = st.wMinute;
	timeformat.tm_hour = st.wHour;
	timeformat.tm_mday = st.wDay;
	timeformat.tm_mon = st.wMonth - 1;
	timeformat.tm_year = st.wYear - 1900;
	timeformat.tm_isdst = -1;

	time_t time;
	time = mktime(&timeformat);
	return time;
}

int __cdecl main(int argc, char **argv)
{
	Configuration config;
	Windivert wd;

	wd.init(config);
	wd.run(config);

	return 0;
}

//int __cdecl main(int argc, char **argv) {
//
//	vector<size_t> configurationHash;
//	vector<size_t>::iterator itConfHash;
//	string tmp_hash;
//	hash<string> hs;
//	clock_t begin;
//	clock_t end;
//	float timer = 0;
//	string setting;
//	vector<thread> threads;
//	SYSTEMTIME st;
//	HANDLE handle;
//	UINT i;
//	INT16 priority = 0;
//	string localIp4;			// Local ip
//	unsigned char packet[MAXBUF];
//	UINT packet_len;
//	WINDIVERT_ADDRESS addr;
//	PWINDIVERT_IPHDR ip_header;
//	PWINDIVERT_IPV6HDR ipv6_header;
//	PWINDIVERT_ICMPHDR icmp_header;
//	PWINDIVERT_ICMPV6HDR icmpv6_header;
//	PWINDIVERT_TCPHDR tcp_header;
//	PWINDIVERT_UDPHDR udp_header;
//
//	Configuration config;
//
//	localIp4 = getLocalIp();				//H¾adanie local ip
//	if (createDirs() == -1) {
//		exit(EXIT_FAILURE);
//	}
//
//	if (setConfig() == -1) {
//		exit(EXIT_FAILURE);
//	}
//
//	setting = makeSettings();
//
//	if (!setting.empty()) {
//
//		//otvorenie filtra s konkretnym nastavenim
//		handle = WinDivertOpen(setting.c_str(), WINDIVERT_LAYER_NETWORK, priority,
//			WINDIVERT_FLAG_SNIFF);
//
//	}
//	else {
//
//		//otvorenie filtra pre celu prevadzku
//
//		string s = "( ip.DstAddr > " + localIp4 + " or ip.DstAddr < " + localIp4 + " ) ";
//		//cout<< s << endl;
//
//		char* tab2 = (char*)malloc(s.length() * sizeof(char));
//
//		strcpy(tab2, s.c_str());
//		cout << tab2 << endl;
//		//	system("pause");
//		handle = WinDivertOpen(tab2, WINDIVERT_LAYER_NETWORK, priority,
//			WINDIVERT_FLAG_SNIFF);
//		//	system("pause");
//	}
//
//	if (handle == INVALID_HANDLE_VALUE)
//	{
//		fprintf(stderr, "chyba: Nepodarilo sa otvorit WinDivert ovladac (%d)\n",
//			GetLastError());
//		exit(EXIT_FAILURE);
//	}
//
//	//nastavenie parametrov pre frontu paketov
//	if (!WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_LEN, 8192))
//	{
//		fprintf(stderr, "chyba: Nepodarilo sa nastavit dlzky frotny paketov (%d)\n",
//			GetLastError());
//		exit(EXIT_FAILURE);
//	}
//	//nastavenie parametrov pre frontu paketov
//	if (!WinDivertSetParam(handle, WINDIVERT_PARAM_QUEUE_TIME, 2048))
//	{
//		fprintf(stderr, "chyba: Nepodarilo sa nastavit cas fronty paketov (%d)\n",
//			GetLastError());
//		exit(EXIT_FAILURE);
//	}
//
//	begin = clock(); //zaciatok merania casu pre spustenie modulu na posielanie dat
//					 //hlavny cyklus zachytavania paketov    
//	while (TRUE)
//	{
//
//		//precitanie zachyteneho paketu
//		if (!WinDivertRecv(handle, packet, sizeof(packet), &addr, &packet_len))
//		{
//			fprintf(stderr, "upozornenie: Nepodarilo sa otvorit paket (%d)\n",
//				GetLastError());
//			continue;
//		}
//		GetSystemTime(&st);
//
//		time_t time = changeTimeFormat(st);
//		//rozparsovanie jednotlivych hodnot v pakete do struktur
//		WinDivertHelperParsePacket(packet, packet_len, &ip_header,
//			&ipv6_header, &icmp_header, &icmpv6_header, &tcp_header,
//			&udp_header, NULL, NULL);
//
//		//osetrenie, ci bola nacitana IP hlavicka
//		if (ip_header == NULL && ipv6_header == NULL)
//		{
//			fprintf(stderr, "warning: junk packet\n");
//		}
//
//		if (ip_header != NULL) {
//
//			UINT8 *srcAddr = (UINT8*)&ip_header->SrcAddr;
//			UINT8 *dstAddr = (UINT8*)&ip_header->DstAddr;
//			packets_time.insert(pair<UINT16, time_t>(ip_header->Id, time));
//
//			//vytvorenie retazca pre hash
//			tmp_hash = std::to_string(srcAddr[0]);
//			tmp_hash.append(".");
//			tmp_hash.append(std::to_string(srcAddr[1]));
//			tmp_hash.append(".");
//			tmp_hash.append(std::to_string(srcAddr[2]));
//			tmp_hash.append(".");
//			tmp_hash.append(std::to_string(srcAddr[3]));
//
//			if (tcp_header != NULL) {
//				tmp_hash.append(std::to_string(ntohs(tcp_header->SrcPort)));
//			}
//
//			if (udp_header != NULL) {
//				tmp_hash.append(std::to_string(ntohs(udp_header->SrcPort)));
//			}
//			tmp_hash.append(std::to_string(dstAddr[0]));
//			tmp_hash.append(".");
//			tmp_hash.append(std::to_string(dstAddr[1]));
//			tmp_hash.append(".");
//			tmp_hash.append(std::to_string(dstAddr[2]));
//			tmp_hash.append(".");
//			tmp_hash.append(std::to_string(dstAddr[3]));
//
//			if (tcp_header != NULL) {
//				tmp_hash.append(std::to_string(ntohs(tcp_header->DstPort)));
//			}
//
//			if (udp_header != NULL) {
//				tmp_hash.append(std::to_string(ntohs(udp_header->DstPort)));
//			}
//
//			//vyhladanie hash-u v poli
//			itConfHash = std::find(configurationHash.begin(), configurationHash.end(), hs(tmp_hash));
//
//			//ak nebol hash najdeny, vytvori sa nova konfiguracia pre pakety
//			if (itConfHash == configurationHash.end()) {
//				configurationHash.push_back(hs(tmp_hash));
//
//				//konverzia pola znakov na vector
//				vector<unsigned char> tmp_packets(std::begin(packet), std::end(packet));
//
//				//KO
//				mu.lock();
//				packets[hs(tmp_hash)].push_back(tmp_packets);
//				packets_len[hs(tmp_hash)].push_back(packet_len);
//				mu.unlock();
//				threads.push_back(thread((processPackets), hs(tmp_hash)));
//			}
//			else { //ak bol najdeny hash, pakety sa len priradia k nemu
//				vector<unsigned char> tmp(std::begin(packet), std::end(packet));
//
//				//KO
//				mu.lock();
//				packets[hs(tmp_hash)].push_back(tmp);
//				packets_len[hs(tmp_hash)].push_back(packet_len);
//				mu.unlock();
//			}
//
//			tmp_hash.clear();
//		}
//		end = clock();
//		timer = (float)(end - begin) / CLOCKS_PER_SEC;
//
//		if (timer >= SEND_TIME) {
//			mu2.lock();
//			sendDataToCollector();
//			mu2.unlock();
//			begin = clock();
//		}
//
//	}
//	return 0;
//}