#include "Windivert.hpp"

Windivert::Windivert()
{
	mPacket = new char[0xFFFF];
}

Windivert::~Windivert()
{
	if (mWindivert)
		WinDivertClose(mWindivert);

	if (mPacket)
		delete[]mPacket;
}

bool Windivert::init(const Configuration &config)
{
	bool ret{ true };

	// vytvorenie windivert filtra
	mWindivert = WinDivertOpen(config.getWindivertFilter().c_str(), WINDIVERT_LAYER_NETWORK, 0, WINDIVERT_FLAG_SNIFF);

	if (mWindivert == INVALID_HANDLE_VALUE)
	{
		ret = false;
		std::cout << "WinDivertOpen invalid handle value!" << std::endl;
		return ret;
	}

	// nastavenie velkosti fronty
	if (!WinDivertSetParam(mWindivert, WINDIVERT_PARAM_QUEUE_LEN, config.getQueueLenght()))
	{
		ret = false;
		std::cout << "Failed to set queue length!" << std::endl;
		return ret;
	}

	// nastavenie casu paketu
	if (!WinDivertSetParam(mWindivert, WINDIVERT_PARAM_QUEUE_TIME, config.getQueueTime()))
	{
		ret = false;
		std::cout << "Failed to set queue time!" << std::endl;
		return ret;
	}

	return ret;
}

void Windivert::run()
{
	WINDIVERT_ADDRESS address;
	PWINDIVERT_IPHDR ip_header;
	PWINDIVERT_IPV6HDR ipv6_header;
	PWINDIVERT_ICMPHDR icmp_header;
	PWINDIVERT_ICMPV6HDR icmpv6_header;
	PWINDIVERT_TCPHDR tcp_header;
	PWINDIVERT_UDPHDR udp_header;

	UINT packetLenght = 0;

	while (TRUE)
	{
		if (!WinDivertRecv(mWindivert, mPacket, 0xFFFF, &address, &packetLenght))
		{
			std::cout << "Failed to open packet!" << std::endl;
			continue;
		}

		WinDivertHelperParsePacket(mPacket, packetLenght, &ip_header,
			&ipv6_header, &icmp_header, &icmpv6_header, &tcp_header,
			&udp_header, NULL, NULL);

		if (ip_header == NULL && ipv6_header == NULL)
		{
			std::cout << "Junk packet!" << std::endl;
		}
	}
}