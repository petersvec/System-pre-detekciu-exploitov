#include "Windivert.hpp"
#include "Collector.hpp"

Windivert::Windivert()
{
	mPacket = new char[0xFFFF];
}

Windivert::~Windivert()
{
	if (mWindivert)
		WinDivertClose(mWindivert);

	if (mPacket)
		delete[]mPacket;

	if (mOutput.is_open())
		mOutput.close();
}

bool Windivert::init(const Configuration &config)
{
	bool ret{ true };

	// vytvorenie windivert filtra
	mWindivert = WinDivertOpen(config.getWindivertFilter().c_str(), WINDIVERT_LAYER_NETWORK, 0, WINDIVERT_FLAG_SNIFF);

	if (mWindivert == INVALID_HANDLE_VALUE)
	{
		ret = false;
		std::cout << "WinDivertOpen invalid handle value!" << std::endl;
		return ret;
	}

	// nastavenie velkosti fronty
	if (!WinDivertSetParam(mWindivert, WINDIVERT_PARAM_QUEUE_LEN, config.getQueueLenght()))
	{
		ret = false;
		std::cout << "Failed to set queue length!" << std::endl;
		return ret;
	}

	// nastavenie casu paketu
	if (!WinDivertSetParam(mWindivert, WINDIVERT_PARAM_QUEUE_TIME, config.getQueueTime()))
	{
		ret = false;
		std::cout << "Failed to set queue time!" << std::endl;
		return ret;
	}

	mPacketFile += config.getDirectory() + "packets.txt";

	return ret;
}

void Windivert::run(const Configuration &config)
{
	WINDIVERT_ADDRESS address;
	PWINDIVERT_IPHDR ip_header;
	PWINDIVERT_IPV6HDR ipv6_header;
	PWINDIVERT_ICMPHDR icmp_header;
	PWINDIVERT_ICMPV6HDR icmpv6_header;
	PWINDIVERT_TCPHDR tcp_header;
	PWINDIVERT_UDPHDR udp_header;

	UINT packetLenght = 0;

	start = clock();

	while (TRUE)
	{
		if (!WinDivertRecv(mWindivert, mPacket, 0xFFFF, &address, &packetLenght))
		{
			std::cout << "Failed to open packet!" << std::endl;
			continue;
		}

		WinDivertHelperParsePacket(mPacket, packetLenght, &ip_header,
			&ipv6_header, &icmp_header, &icmpv6_header, &tcp_header,
			&udp_header, NULL, NULL);

		if (ip_header == NULL && ipv6_header == NULL)
		{
			std::cout << "Junk packet!" << std::endl;
		} else writePacket(mPacket, packetLenght);

		// kontrola casu na odoslanie suborov
		end = clock();
		unsigned time = static_cast<unsigned>((end - start) / CLOCKS_PER_SEC);
		
		if (time >= config.getSendingTime())
		{
			std::cout << "Sending data to collector!" << std::endl;
			start = clock();

			mOutput << "End of Packets File\n";
			mOutput.close();

			// skusame postupne vsetky kolektory az kym sa nepodari odoslat data
			for (auto &col : collectors)
				if (col.send(config))
					break;
		}
	}
}

void Windivert::writePacket(char *data, UINT size)
{
	SYSTEMTIME st;
	GetSystemTime(&st);

	time_t packetTime = convert(st);

	// otvorenie streamu na zapis
	if (!mOutput.is_open())
		mOutput.open(mPacketFile, std::ofstream::out | std::ofstream::trunc);
	
	mOutput << std::dec << packetTime << "\n";
	
	for (int i = 0; i < size; i++)
	{
		if (i && !(i % 16))
			mOutput << "\n";
		mOutput << std::setw(2) <<std::hex << std::uppercase << (unsigned)(data[i]) << " ";
	}
	
	mOutput << "\n";
	mOutput << "End of packet\n\n";
}

time_t Windivert::convert(SYSTEMTIME st)
{
	tm tf;

	tf.tm_sec = st.wSecond;
	tf.tm_min = st.wMinute;
	tf.tm_hour = st.wHour;
	tf.tm_mday = st.wDay;
	tf.tm_mon = st.wMonth - 1;
	tf.tm_year = st.wYear - 1900;
	tf.tm_isdst = -1;

	time_t time;
	time = mktime(&tf);
	return time;
}