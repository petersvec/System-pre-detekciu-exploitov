#include "Collector.hpp"

std::vector<Collector> collectors;

Collector::Collector(const std::string &ip, const std::string &port)
{
	mIPAddress = ip;
	mPort = port;
}

bool Collector::send(const Configuration &configuration)
{
	DWORD ret;

	memset((STARTUPINFO*)&startupInfo, 0, sizeof(startupInfo));
	memset((PROCESS_INFORMATION*)&processInfo, 0, sizeof(processInfo));

	std::string workingDirectory = configuration.getWorkingDirectory();
	std::string application = workingDirectory + "CollectorSender.exe";
	std::string arguments = "";

	if (!CreateProcess(application.c_str(), (LPSTR)arguments.c_str(), NULL, FALSE, 0, NULL, NULL, NULL, &startupInfo, &processInfo))
	{
		std::cout << "[Collector] Failed to create CollectorSender process!" << std::endl;
		return false;
	}

	ret = WaitForSingleObject(processInfo.hProcess, mTimeout);

	if (ret == WAIT_OBJECT_0)
	{
		GetExitCodeProcess(processInfo.hProcess, &ret);
		int returnValue = static_cast<int>(ret);

		if (!returnValue)
		{
			std::cout << "[Collector] 0 returned from CollectorSender process!" << std::endl;
			closeHandles();
			return false;
		}
	}
	else if (ret == WAIT_TIMEOUT)
	{
		std::cout << "[Collector] Timeout in WaitForSingleObject!" << std::endl;	
		closeHandles();
		return false;
	}
	else if (ret == WAIT_FAILED)
	{
		std::cout << "[Collector] WaitForSingleObject failed!" << std::endl;
		closeHandles();
		return false;
	}

	closeHandles();

	return true;
}

void Collector::closeHandles()
{
	CloseHandle(processInfo.hProcess);
	CloseHandle(processInfo.hThread);
}