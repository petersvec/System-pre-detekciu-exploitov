#include "Collector.hpp"
#include "Configuration.hpp"

std::vector<Collector> collectors;

Collector::Collector(const std::string &ip, const std::string &port)
{
	mIPAddress = ip;
	mPort = port;

	io_service = std::make_shared<asio::io_service>();
	mSocket = std::make_shared<asio::ip::tcp::socket>(*io_service);
}

bool Collector::send(const Configuration &configuration)
{
	DWORD ret;

	memset((STARTUPINFO*)&startupInfo, 0, sizeof(startupInfo));
	memset((PROCESS_INFORMATION*)&processInfo, 0, sizeof(processInfo));

	std::string workingDirectory = configuration.getWorkingDirectory();
	std::string application = workingDirectory + "CollectorSender.exe";
	std::string arguments = "";

	if (!CreateProcess(application.c_str(), (LPSTR)arguments.c_str(), NULL, FALSE, 0, NULL, NULL, NULL, &startupInfo, &processInfo))
	{
		std::cout << "[Collector] Failed to create CollectorSender process!" << std::endl;
		return false;
	}

	ret = WaitForSingleObject(processInfo.hProcess, mTimeout);

	if (ret == WAIT_OBJECT_0)
	{
		GetExitCodeProcess(processInfo.hProcess, &ret);
		int returnValue = static_cast<int>(ret);

		if (!returnValue)
		{
			std::cout << "[Collector] 0 returned from CollectorSender process!" << std::endl;
			closeHandles();
			return false;
		}
	}
	else if (ret == WAIT_TIMEOUT)
	{
		std::cout << "[Collector] Timeout in WaitForSingleObject!" << std::endl;	
		closeHandles();
		return false;
	}
	else if (ret == WAIT_FAILED)
	{
		std::cout << "[Collector] WaitForSingleObject failed!" << std::endl;
		closeHandles();
		return false;
	}

	closeHandles();

	return true;
}

bool Collector::sendTo(const Configuration &configuration)
{
	std::string path = configuration.getDirectory() + "packets.txt";

	if (establishConnection())
	{
		std::ifstream input(path, std::ofstream::in);

		if (input.is_open())
		{
			// nacitanie obsahu suboru
			std::string data((std::istreambuf_iterator<char>(input)),
							  std::istreambuf_iterator<char>());

			// vypocet velkosti
			long size{ 0 };

			// z java collectora: 36? preco?
			size += data.size() + 36 + mDataType.size() + mDebuggingInfo.size() + mSource.size() + mStreamName.size() + mTags.size();

			std::string header = createHTTPHeader(size);
			std::string finalData{ "" };

			// TODO: niektore props este prekontrolovat
			finalData += header;
			finalData += std::to_string(mEvent);
			finalData += std::to_string(mProtocol);
			finalData += std::to_string(data.size());
			finalData += mSource;
			finalData += mTags;
			finalData += mStreamName;
			finalData += mDataType;
			finalData += mDebuggingInfo;
			finalData += std::to_string(mRecordEndOffsets);
			finalData += std::to_string(data.size() - 1);
			finalData += data;

			// poslanie dat
			asio::error_code error;
			std::size_t bytesSent = asio::write(*mSocket, asio::buffer(finalData), error);
			std::cout << "[Collector] Bytes sent to collector: " << bytesSent << std::endl;
			
			std::cout << "[Collector] Closing connection!" << std::endl;
			mSocket->close();
		}
		else
		{
			std::cout << "[Collector] Failed to open file: " << path << std::endl;
			return false;
		}
	}

	return false;
}

void Collector::closeHandles()
{
	CloseHandle(processInfo.hProcess);
	CloseHandle(processInfo.hThread);
}

bool Collector::establishConnection()
{
	asio::ip::tcp::endpoint endpoint(asio::ip::address::from_string(mIPAddress.c_str()), atoi(mPort.c_str()));

	try {
		std::cout << "[Collector] Connecting to: " << mIPAddress << ":" << mPort << std::endl;
		mSocket->connect(endpoint);
	}
	catch (std::exception &e)
	{
		std::cout << "[Collector] Exception: " << e.what() << std::endl;
		return false;
	}

	return true;
}

std::string Collector::createHTTPHeader(long size) const
{
	std::string header{ "" };

	header += "POST http://" + mIPAddress + ":" + mPort + "/chukwa HTTP/1.1\r\n";
	header += "User-Agent: Jakarta Commons-HttpClient/3.0.1\r\n";
	header += "Host: " + mIPAddress + ":" + mPort + "\r\n";
	header += "Content-Length: " + std::to_string(size) + "\r\n";
	header += "Content-Type: application/octet-stream\r\n";
	header += "\r\n";

	return header;
}